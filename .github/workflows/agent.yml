name: Agent
run-name: Run PhiZone Player [${{ github.event.inputs.id }}]
on:
  workflow_dispatch:
    inputs:
      id:
        description: 'Run ID'
        required: true
      files:
        description: 'Input files'
        required: true
      toggles:
        description: 'Toggles'
        required: false
        default: '{"autostart":true,"autoplay":true,"practice":false,"adjustOffset":false,"render":true,"newTab":true,"inApp":0}'
      preferences:
        description: 'Player preferences'
        required: false
        default: '{"aspectRatio":null,"backgroundBlur":1,"backgroundLuminance":0.5,"chartFlipping":0,"chartOffset":0,"fcApIndicator":true,"goodJudgment":160,"hitSoundVolume":0.75,"lineThickness":1,"musicVolume":1,"noteSize":1,"perfectJudgment":80,"simultaneousNoteHint":true,"timeScale":1}'
      mediaOptions:
        description: 'Renderer media options'
        required: false
        default: '{"frameRate":60,"overrideResolution":[1620,1080],"resultsLoopsToRender":1,"videoCodec":"libx264","videoBitrate":6000,"audioBitrate":320,"vsync":true,"exportPath":""}'
      webhookUrl:
        description: 'Webhook URL'
        required: false
      timezone:
        description: 'Timezone'
        required: false
        default: 'Asia/Shanghai'
      useSnapshot:
        description: 'Use latest snapshot'
        required: false
        type: boolean
        default: false

defaults:
  run:
    shell: bash

jobs:
  agent:
    name: Run PhiZone Player
    runs-on: macos-latest
    steps:
      - name: Set timezone
        uses: szenius/set-timezone@v2.0
        with:
          timezoneLinux: ${{ github.event.inputs.timezone }}
          timezoneMacos: ${{ github.event.inputs.timezone }}
          timezoneWindows: ${{ github.event.inputs.timezone }}

      - name: Notify webhook about job initialization
        if: ${{ github.event.inputs.webhookUrl }}
        run: |
          set -e

          run_id='${{ github.event.inputs.id }}'
          webhook_url='${{ github.event.inputs.webhookUrl }}'

          curl -X POST -H "Content-Type: application/json" -d "{
            \"run_id\": \"$run_id\",
            \"status\": \"initializing\",
            \"progress\": 0
          }" "$webhook_url" 2>/dev/null || echo "Failed to send initialization notification"

      - name: Obtain Player executable download URL
        id: get_url
        uses: actions/github-script@v7
        with:
          script: |
            const useSnapshot = '${{ github.event.inputs.useSnapshot }}' === 'true';

            let release;
            if (useSnapshot) {
              // Get latest prerelease
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              release = releases.find(r => r.prerelease);
              if (!release) throw new Error('No prerelease found');
            } else {
              // Get latest stable release
              const { data: latestRelease } = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              release = latestRelease;
            }

            const tag = release.tag_name;
            const version = tag.replace(/^v/, '');
            const assetName = `PhiZone.Player-${version}-macos-arm64`;

            const asset = release.assets.find(a => a.name === assetName);
            if (!asset) throw new Error(`Asset ${assetName} not found`);
            core.setOutput('asset_url', asset.browser_download_url);

      - name: Download Player executable
        run: |
          curl -L "${{ steps.get_url.outputs.asset_url }}" -o player
          chmod +x player

      - name: Setup FFmpeg
        uses: AnimMouse/setup-ffmpeg@v1

      - name: Prepare media options
        id: prepare_options
        run: |
          set -e
          mkdir -p ./outputs
          outputs_path=$(realpath ./outputs)
          echo "outputs_path=$outputs_path" >> $GITHUB_OUTPUT

          mediaOptions='${{ github.event.inputs.mediaOptions }}'
          if [ -n "$mediaOptions" ]; then
            # Parse JSON, override exportPath, and serialize back (compact output)
            mediaOptions=$(echo "$mediaOptions" | jq -c --arg path "$outputs_path" '.exportPath = $path')
            echo "mediaOptions=$mediaOptions" >> $GITHUB_OUTPUT
          else
            echo "mediaOptions=" >> $GITHUB_OUTPUT
          fi

      - name: Download and prepare input files
        id: prepare_files
        run: |
          set -e
          files_input='${{ github.event.inputs.files }}'

          # Create downloads directory
          mkdir -p ./downloads
          downloads_path=$(realpath ./downloads)

          # Accept either a JSON array (e.g. ["a","b"]) or a newline-separated list.
          files_raw=""
          if printf '%s' "$files_input" | jq -e . >/dev/null 2>&1; then
            # It's valid JSON: extract array elements joined by newlines
            files_raw=$(echo "$files_input" | jq -r '.[]')
          else
            files_raw="$files_input"
          fi

          # Read lines into array (safe for spaces in names)
          IFS=$'\n' read -r -d '' -a files_array < <(printf '%s\0' "$files_raw")
          # Remove trailing '\r' from each element
          for i in "${!files_array[@]}"; do
            files_array[$i]="${files_array[$i]%$'\r'}"
          done

          # Download files and collect local paths
          local_files=()
          file_counter=1

          for file in "${files_array[@]}"; do
            [ -z "$file" ] && continue
            
            echo "Processing file: $file"
            
            if [[ "$file" =~ ^https?:// ]]; then
              # It's a URL, download it with UUID filename
              
              # Extract extension from URL (remove query parameters first)
              clean_url="${file%%\?*}"
              extension=""
              
              # Try to get extension from the clean URL
              if [[ "$clean_url" =~ \.[a-zA-Z0-9]+$ ]]; then
                extension="${clean_url##*.}"
              else
                # Default to zip if no extension found
                extension="zip"
              fi
              
              # Generate UUID for filename (using timestamp + random for uniqueness)
              uuid=$(date +%s%N | sha256sum | head -c 8)
              filename="${uuid}.${extension}"
              
              local_path="$downloads_path/$filename"
              echo "Downloading $file to $local_path"
              
              if curl -L -f -o "$local_path" "$file"; then
                echo "Successfully downloaded: $filename"
                local_files+=("$local_path")
              else
                echo "Failed to download: $file"
                exit 1
              fi
            else
              # It's already a local path
              echo "Using local file: $file"
              local_files+=("$file")
            fi
            
            ((file_counter++))
          done

          # Convert array to newline-separated string for output
          printf '%s\n' "${local_files[@]}" > ./files.txt
          echo "local_files_path=$(realpath ./files.txt)" >> $GITHUB_OUTPUT

          echo "Prepared ${#local_files[@]} local files:"
          for file in "${local_files[@]}"; do
            echo "  - $file"
          done

      - name: Run player executable
        env:
          REPORT_INTERVAL: '25'
          __XPC_JSC_useSharedArrayBuffer: '1'
        run: |
          set -e
          local_files_path='${{ steps.prepare_files.outputs.local_files_path }}'
          toggles='${{ github.event.inputs.toggles }}'
          preferences='${{ github.event.inputs.preferences }}'
          mediaOptions='${{ steps.prepare_options.outputs.mediaOptions }}'
          webhook_url='${{ github.event.inputs.webhookUrl }}'
          run_id='${{ github.event.inputs.id }}'

          # Notify webhook that rendering is starting
          if [ -n "$webhook_url" ]; then
            curl -X POST -H "Content-Type: application/json" -d "{
              \"run_id\": \"$run_id\",
              \"status\": \"starting\",
              \"progress\": 0
            }" "$webhook_url" 2>/dev/null || echo "Failed to send start notification"
          fi

          # Read local file paths from the prepared list
          files_array=()
          while IFS= read -r line || [ -n "$line" ]; do
            files_array+=("$line")
          done < "$local_files_path"

          # Build the command with proper argument handling
          cmd_args=()

          # Add file arguments
          for file in "${files_array[@]}"; do
            [ -z "$file" ] && continue
            cmd_args+=("$file")
          done

          # Add optional arguments with proper quoting
          if [ -n "$toggles" ]; then
            cmd_args+=("--toggles" "$toggles")
          fi
          if [ -n "$preferences" ]; then
            cmd_args+=("--preferences" "$preferences")
          fi
          if [ -n "$mediaOptions" ]; then
            cmd_args+=("--mediaOptions" "$mediaOptions")
          fi

          cmd_args+=("--automate")

          echo "Starting player execution..."

          # Create temporary log file for capturing output
          log_file=$(mktemp /tmp/player.XXXXXX)
          echo "Created log file: $log_file"

          # Start progress monitoring in background (only if webhook URL is provided)
          progress_monitor_pid=""
          if [ -n "$webhook_url" ]; then
            (
              echo "Starting progress monitor..."
              last_reported_progress=""
              
              while [ -f "$log_file" ]; do
                if [ -f "$log_file" ]; then
                  # Look for the most recent progress line in the log file
                  # Pattern handles: [TAURI] Rendering: + (1+ spaces) + percentage + % + (1+ spaces) + ( + (0+ spaces) + current/total + )
                  progress_line=$(grep -o '\[TAURI\] Rendering: \+[0-9.]\+% \+([ ]*[0-9]\+/[0-9]\+)' "$log_file" 2>/dev/null | tail -1 || true)
                  
                  if [ -n "$progress_line" ]; then
                    # Extract progress percentage (handles multiple spaces after "Rendering:")
                    progress_percent=$(echo "$progress_line" | sed -n 's/.*Rendering: \+\([0-9.]\+\)%.*/\1/p')
                    # Extract current/total numbers (handles spaces before the numbers in parentheses)
                    progress_numbers=$(echo "$progress_line" | sed -n 's/.*([ ]*\([0-9]\+/[0-9]\+\)).*/\1/p')
                    
                    if [ -n "$progress_percent" ] && [ -n "$progress_numbers" ]; then
                      # Convert percentage to decimal (0.0 to 1.0)
                      progress_decimal=$(echo "scale=4; $progress_percent / 100" | bc -l 2>/dev/null || echo "0")
                      
                      # Only report if progress has changed
                      if [ "$progress_decimal" != "$last_reported_progress" ]; then
                        echo "Progress detected: $progress_percent% ($progress_numbers) -> $progress_decimal"
                        
                        # Send progress update to webhook
                        curl -X POST -H "Content-Type: application/json" -d "{
                          \"run_id\": \"$run_id\",
                          \"status\": \"rendering\",
                          \"progress\": $progress_decimal,
                          \"details\": \"$progress_numbers\"
                        }" "$webhook_url" 2>/dev/null || echo "Failed to send progress update"
                        
                        last_reported_progress="$progress_decimal"
                      fi
                    fi
                  fi
                fi
                sleep 2
              done
              echo "Progress monitor stopped."
            ) &
            progress_monitor_pid=$!
            echo "Progress monitor started with PID: $progress_monitor_pid"
          fi

          # Start memory monitoring in background
          (
            while true; do
              # Memory usage (macOS: vm_stat and sysctl)
              mem_total=$(sysctl -n hw.memsize)
              mem_free=$(vm_stat | awk '/Pages free/ {print $3}' | tr -d '.')
              mem_inactive=$(vm_stat | awk '/Pages inactive/ {print $3}' | tr -d '.')
              page_size=$(vm_stat | head -1 | awk '{print $8}')
              mem_free_bytes=$(( (mem_free + mem_inactive) * page_size ))
              mem_occupied_bytes=$((mem_total - mem_free_bytes))
              mem_total_gb=$(echo "scale=2; $mem_total/1024/1024/1024" | bc)
              mem_occupied_gb=$(echo "scale=2; $mem_occupied_bytes/1024/1024/1024" | bc)
              mem_percent=$(echo "scale=1; ($mem_occupied_bytes*100)/$mem_total" | bc)
              echo -e "\nMemory: ${mem_occupied_gb} GiB / ${mem_total_gb} GiB (${mem_percent}%)"
              sleep 60
            done
          ) &
          memory_monitor_pid=$!

          # Execute player with output redirection to both console and log file
          echo "Executing: ./player ${cmd_args[*]}"
          ./player "${cmd_args[@]}" 2>&1 | tee "$log_file"
          player_exit_code=${PIPESTATUS[0]}

          # Stop monitoring processes
          if [ -n "$progress_monitor_pid" ]; then
            kill $progress_monitor_pid 2>/dev/null || true
            wait $progress_monitor_pid 2>/dev/null || true
          fi
          kill $memory_monitor_pid 2>/dev/null || true
          wait $memory_monitor_pid 2>/dev/null || true

          # Clean up log file
          rm -f "$log_file" 2>/dev/null || true

          echo "Player execution completed with exit code: $player_exit_code"

          exit $player_exit_code

      - name: Upload output artifact
        id: upload
        uses: actions/upload-artifact@v4
        with:
          name: artifact
          path: ${{ steps.prepare_options.outputs.outputs_path }}

      - name: Notify webhook about job completion
        if: ${{ github.event.inputs.webhookUrl }}
        run: |
          set -e

          run_id='${{ github.event.inputs.id }}'
          artifact_id='${{ steps.upload.outputs.artifact-id }}'
          webhook_url='${{ github.event.inputs.webhookUrl }}'

          curl -X POST -H "Content-Type: application/json" -d "{
            \"run_id\": \"$run_id\",
            \"status\": \"completed\",
            \"progress\": 1,
            \"artifact_id\": \"$artifact_id\"
          }" "$webhook_url" 2>/dev/null || echo "Failed to send completion notification"

      - name: Post-execution cleanup
        if: always()
        run: |
          set -e
          echo "Starting post-execution cleanup..."

          # Clean up downloaded files
          echo "Cleaning downloaded files..."
          rm -rf ./downloads 2>/dev/null || true

          # Clean up generated outputs
          echo "Cleaning local output files..."
          rm -rf ./outputs 2>/dev/null || true
          rm -rf ./files.txt 2>/dev/null || true

          # Clean up player executable
          rm -f ./player 2>/dev/null || true

          # Clean up Tauri app data
          if [ -d "$APPDATA" ]; then
            rm -rf "$APPDATA/cn.phizone.player" 2>/dev/null || true
          fi

          if [ -d "$LOCALAPPDATA" ]; then
            rm -rf "$LOCALAPPDATA/cn.phizone.player" 2>/dev/null || true
          fi

          # Clean up any WebView2 processes and cache
          echo "Cleaning WebView2 cache post-execution..."
          if [ -d "$LOCALAPPDATA/Microsoft/Edge" ]; then
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Cache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Code Cache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/GPUCache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Service Worker" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/IndexedDB" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Local Storage" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Session Storage" 2>/dev/null || true
          fi

          echo "Post-execution cleanup completed."
