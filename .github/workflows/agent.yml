name: Agent
run-name: Run PhiZone Player [${{ github.event.inputs.id }}]
on:
  workflow_dispatch:
    inputs:
      id:
        description: 'Run ID'
        required: true
      files:
        description: 'Input files'
        required: true
      toggles:
        description: 'Toggles'
        required: false
        default: '{"autostart":true,"autoplay":true,"practice":false,"adjustOffset":false,"render":true,"newTab":true,"inApp":0}'
      preferences:
        description: 'Player preferences'
        required: false
        default: '{"aspectRatio":null,"backgroundBlur":1,"backgroundLuminance":0.5,"chartFlipping":0,"chartOffset":0,"fcApIndicator":true,"goodJudgment":160,"hitSoundVolume":0.75,"lineThickness":1,"musicVolume":1,"noteSize":1,"perfectJudgment":80,"simultaneousNoteHint":true,"timeScale":1}'
      mediaOptions:
        description: 'Renderer media options'
        required: false
        default: '{"frameRate":60,"overrideResolution":[1620,1080],"resultsLoopsToRender":1,"videoCodec":"libx264","videoBitrate":6000,"audioBitrate":320,"vsync":true,"exportPath":""}'
      useSnapshot:
        description: 'Use latest snapshot'
        required: false
        type: boolean
        default: false

defaults:
  run:
    shell: bash

jobs:
  agent:
    name: Run PhiZone Player
    runs-on: macos-latest
    steps:
      - name: Obtain Player executable download URL
        id: get_url
        uses: actions/github-script@v7
        with:
          script: |
            const useSnapshot = '${{ github.event.inputs.useSnapshot }}' === 'true';

            let release;
            if (useSnapshot) {
              // Get latest prerelease
              const { data: releases } = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo,
                per_page: 100
              });
              release = releases.find(r => r.prerelease);
              if (!release) throw new Error('No prerelease found');
            } else {
              // Get latest stable release
              const { data: latestRelease } = await github.rest.repos.getLatestRelease({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              release = latestRelease;
            }

            const tag = release.tag_name;
            const version = tag.replace(/^v/, '');
            const assetName = `PhiZone.Player-${version}-macos-arm64`;

            const asset = release.assets.find(a => a.name === assetName);
            if (!asset) throw new Error(`Asset ${assetName} not found`);
            core.setOutput('asset_url', asset.browser_download_url);

      - name: Download Player executable
        run: |
          curl -L "${{ steps.get_url.outputs.asset_url }}" -o player
          chmod +x player

      - name: Setup FFmpeg
        uses: AnimMouse/setup-ffmpeg@v1

      - name: Prepare media options
        id: prepare_options
        run: |
          set -e
          mkdir -p ./outputs
          outputs_path=$(realpath ./outputs)
          echo "outputs_path=$outputs_path" >> $GITHUB_OUTPUT

          mediaOptions='${{ github.event.inputs.mediaOptions }}'
          if [ -n "$mediaOptions" ]; then
            # Parse JSON, override exportPath, and serialize back (compact output)
            mediaOptions=$(echo "$mediaOptions" | jq -c --arg path "$outputs_path" '.exportPath = $path')
            echo "mediaOptions=$mediaOptions" >> $GITHUB_OUTPUT
          else
            echo "mediaOptions=" >> $GITHUB_OUTPUT
          fi

      - name: Download and prepare input files
        id: prepare_files
        run: |
          set -e
          files_input='${{ github.event.inputs.files }}'

          # Create downloads directory
          mkdir -p ./downloads
          downloads_path=$(realpath ./downloads)

          # Accept either a JSON array (e.g. ["a","b"]) or a newline-separated list.
          files_raw=""
          if printf '%s' "$files_input" | jq -e . >/dev/null 2>&1; then
            # It's valid JSON: extract array elements joined by newlines
            files_raw=$(echo "$files_input" | jq -r '.[]')
          else
            files_raw="$files_input"
          fi

          # Read lines into array (safe for spaces in names)
          IFS=$'\n' read -r -d '' -a files_array < <(printf '%s\0' "$files_raw")
          # Remove trailing '\r' from each element
          for i in "${!files_array[@]}"; do
            files_array[$i]="${files_array[$i]%$'\r'}"
          done

          # Download files and collect local paths
          local_files=()
          file_counter=1

          for file in "${files_array[@]}"; do
            [ -z "$file" ] && continue
            
            echo "Processing file: $file"
            
            if [[ "$file" =~ ^https?:// ]]; then
              # It's a URL, download it with UUID filename
              
              # Extract extension from URL (remove query parameters first)
              clean_url="${file%%\?*}"
              extension=""
              
              # Try to get extension from the clean URL
              if [[ "$clean_url" =~ \.[a-zA-Z0-9]+$ ]]; then
                extension="${clean_url##*.}"
              else
                # Default to zip if no extension found
                extension="zip"
              fi
              
              # Generate UUID for filename (using timestamp + random for uniqueness)
              uuid=$(date +%s%N | sha256sum | head -c 8)
              filename="${uuid}.${extension}"
              
              local_path="$downloads_path/$filename"
              echo "Downloading $file to $local_path"
              
              if curl -L -f -o "$local_path" "$file"; then
                echo "Successfully downloaded: $filename"
                local_files+=("$local_path")
              else
                echo "Failed to download: $file"
                exit 1
              fi
            else
              # It's already a local path
              echo "Using local file: $file"
              local_files+=("$file")
            fi
            
            ((file_counter++))
          done

          # Convert array to newline-separated string for output
          printf '%s\n' "${local_files[@]}" > ./files.txt
          echo "local_files_path=$(realpath ./files.txt)" >> $GITHUB_OUTPUT

          echo "Prepared ${#local_files[@]} local files:"
          for file in "${local_files[@]}"; do
            echo "  - $file"
          done

      - name: Run player executable
        env:
          REPORT_INTERVAL: '25'
          __XPC_JSC_useSharedArrayBuffer: '1'
        run: |
          set -e
          local_files_path='${{ steps.prepare_files.outputs.local_files_path }}'
          toggles='${{ github.event.inputs.toggles }}'
          preferences='${{ github.event.inputs.preferences }}'
          mediaOptions='${{ steps.prepare_options.outputs.mediaOptions }}'

          # Read local file paths from the prepared list
          files_array=()
          while IFS= read -r line || [ -n "$line" ]; do
            files_array+=("$line")
          done < "$local_files_path"

          # Build the command with proper argument handling
          cmd_args=()

          # Add file arguments
          for file in "${files_array[@]}"; do
            [ -z "$file" ] && continue
            cmd_args+=("$file")
          done

          # Add optional arguments with proper quoting
          if [ -n "$toggles" ]; then
            cmd_args+=("--toggles" "$toggles")
          fi
          if [ -n "$preferences" ]; then
            cmd_args+=("--preferences" "$preferences")
          fi
          if [ -n "$mediaOptions" ]; then
            cmd_args+=("--mediaOptions" "$mediaOptions")
          fi

          cmd_args+=("--automate")

          echo "Starting player execution..."

          # Start monitoring in background
          (
            while true; do
              # Memory usage (macOS: vm_stat and sysctl)
              mem_total=$(sysctl -n hw.memsize)
              mem_free=$(vm_stat | awk '/Pages free/ {print $3}' | tr -d '.')
              mem_inactive=$(vm_stat | awk '/Pages inactive/ {print $3}' | tr -d '.')
              page_size=$(vm_stat | head -1 | awk '{print $8}')
              mem_free_bytes=$(( (mem_free + mem_inactive) * page_size ))
              mem_occupied_bytes=$((mem_total - mem_free_bytes))
              mem_total_gb=$(echo "scale=2; $mem_total/1024/1024/1024" | bc)
              mem_occupied_gb=$(echo "scale=2; $mem_occupied_bytes/1024/1024/1024" | bc)
              mem_percent=$(echo "scale=1; ($mem_occupied_bytes/$mem_total)*100" | bc)
              echo ""
              echo "Memory: ${mem_occupied_gb} GiB / ${mem_total_gb} GiB (${mem_percent}%)"
              echo ""
              sleep 60
            done
          ) &
          monitor_pid=$!

          # Execute player
          echo "Executing: ./player ${cmd_args[*]}"
          ./player "${cmd_args[@]}"
          player_exit_code=$?

          # Stop monitoring
          kill $monitor_pid 2>/dev/null || true
          wait $monitor_pid 2>/dev/null || true

          echo "Player execution completed with exit code: $player_exit_code"

          exit $player_exit_code

      - name: Prepare output artifacts
        id: prepare_artifact
        run: |
          set -e
          outputs_path="${{ steps.prepare_options.outputs.outputs_path }}"

          # Find the generated folder in outputs directory
          if [ -d "$outputs_path" ]; then
            # Get the first (and presumably only) subdirectory in outputs
            artifact_folder=$(find "$outputs_path" -mindepth 1 -maxdepth 1 -type d | head -n 1)

            if [ -n "$artifact_folder" ]; then
              folder_name=$(basename "$artifact_folder")
              echo "Found artifact folder: $folder_name"
              echo "Contents of $artifact_folder:"
              ls -lh "$artifact_folder"
              echo "folder_name=$folder_name" >> $GITHUB_OUTPUT
            else
              echo "No artifact folder found in $outputs_path"
              exit 1
            fi
          else
            echo "Outputs directory does not exist"
            exit 1
          fi

      - name: Upload output artifacts
        if: steps.prepare_artifact.outputs.folder_name != ''
        uses: actions/upload-artifact@v4
        with:
          name: artifact-${{ github.event.inputs.id }}
          path: ${{ steps.prepare_options.outputs.outputs_path }}

      - name: Post-execution cleanup
        if: always()
        run: |
          set -e
          echo "Starting post-execution cleanup..."

          # Clean up downloaded files
          echo "Cleaning downloaded files..."
          rm -rf ./downloads 2>/dev/null || true

          # Clean up generated outputs
          echo "Cleaning local output files..."
          rm -rf ./outputs 2>/dev/null || true
          rm -rf ./files.txt 2>/dev/null || true

          # Clean up player executable
          rm -f ./player 2>/dev/null || true

          # Clean up Tauri app data
          if [ -d "$APPDATA" ]; then
            rm -rf "$APPDATA/cn.phizone.player" 2>/dev/null || true
          fi

          if [ -d "$LOCALAPPDATA" ]; then
            rm -rf "$LOCALAPPDATA/cn.phizone.player" 2>/dev/null || true
          fi

          # Clean up any WebView2 processes and cache
          echo "Cleaning WebView2 cache post-execution..."
          if [ -d "$LOCALAPPDATA/Microsoft/Edge" ]; then
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Cache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Code Cache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/GPUCache" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Service Worker" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/IndexedDB" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Local Storage" 2>/dev/null || true
            rm -rf "$LOCALAPPDATA/Microsoft/Edge/User Data/Default/Session Storage" 2>/dev/null || true
          fi

          echo "Post-execution cleanup completed."
